import clsx from 'clsx'
import React, { useCallback, useMemo, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Column } from 'react-virtualized'

import Box from '@material-ui/core/Box'
import Paper from '@material-ui/core/Paper'
import TableCell from '@material-ui/core/TableCell'

import type { MobileProtectData } from '@ues-data/mtd'
import { queryOsDetails } from '@ues-data/mtd'
import { useStatefulAsyncQuery } from '@ues-data/shared'
import { FILTER_TYPES, meetsFilter, QuickSearchFilter, STRING_OPERATORS, useFilter } from '@ues/behaviours'

import type { TabProps } from './shared/useInfiniteTable'
import { InfiniteTable, Loading, NoData, standardWidth, useInfiniteTable } from './shared/useInfiniteTable'
import { useQuickSearchFilter } from './shared/useQuickSearchFilter'

const ROW_HEIGHT = 53
const HEADER_HEIGHT = 53

const Filter = props => {
  const filterProps = useQuickSearchFilter(props)
  return <QuickSearchFilter label={props.label} operators={STRING_OPERATORS} {...filterProps} />
}

const UsersTab: React.FC<TabProps> = React.memo(({ value, index, oss }) => {
  const { t } = useTranslation(['mtd/common', 'mtd/vulnerability'])
  const { activeFilters, onSetFilter, onRemoveFilter } = useFilter()
  const { classes } = useInfiniteTable()
  const [moreData, setMoreData] = useState({ data: [], cursor: null })

  const columns = useMemo(
    () => [
      {
        label: t('user'),
        dataKey: 'user',
        filterType: FILTER_TYPES.QUICK_SEARCH,
      },
      {
        label: t('email'),
        dataKey: 'email',
        filterType: FILTER_TYPES.QUICK_SEARCH,
      },
      {
        label: t('manufacturer'),
        dataKey: 'manufacturer',
        filterType: FILTER_TYPES.QUICK_SEARCH,
      },
      {
        label: t('deviceModel'),
        dataKey: 'deviceModel',
        filterType: FILTER_TYPES.QUICK_SEARCH,
      },
    ],
    [t],
  )

  function getDeviceModel(endpointInfo: MobileProtectData.EndpointInfo): string {
    return endpointInfo.deviceModelName ? endpointInfo.deviceModelName : endpointInfo.deviceModelAlias
  }

  const processUserData = useCallback(
    (data: MobileProtectData.Response<MobileProtectData.PagedResponse<MobileProtectData.OsDetails>>) => {
      const dataSubset = []
      if (data !== undefined) {
        for (const entry of data.data.elements) {
          dataSubset.push({
            user: entry.user.displayName,
            email: entry.user.email,
            manufacturer: entry.endpoint.manufacturer,
            deviceModel: getDeviceModel(entry.endpoint),
          })
        }
      }
      return dataSubset
    },
    [],
  )

  const headerRowRenderer = ({ className, columns, style }) => {
    return (
      <>
        <div className={className} style={style}>
          {columns}
        </div>
        {loading && <Loading style={style} />}
      </>
    )
  }

  const headerRenderer = ({ column, columnIndex, style }) => {
    return (
      <TableCell
        component="div"
        className={clsx('MuiTableCell-head', classes.headCell, classes.flexContainer, classes.noClick)}
        key={column.dataKey}
        style={style}
      >
        <Box display="flex" flex={1} alignItems="center">
          <Box flexGrow={1}>
            {column.label}
            <Filter
              label={column.label}
              activeFilters={activeFilters}
              onSetFilter={onSetFilter}
              onRemoveFilter={onRemoveFilter}
              columnId={column.dataKey}
            />
          </Box>
        </Box>
      </TableCell>
    )
  }

  const cellRenderer = ({ cellData, column }) => {
    return (
      <TableCell component="div" className={classes.cellContent} style={{ height: ROW_HEIGHT }} align={column.align ?? 'left'}>
        {cellData}
      </TableCell>
    )
  }

  const noDataRenderer = () => {
    return <NoData noDataLabel={t('noDataLabel')} />
  }

  const request = useMemo(() => {
    return { oss: oss.map(os => os.os), cursor: moreData.cursor }
  }, [moreData.cursor, oss])

  const { loading, data: osDetailsData } = useStatefulAsyncQuery(queryOsDetails, {
    variables: request,
    skip: value !== index || oss.length === undefined || oss.length === 0,
  })

  const localData = useMemo(() => {
    const newData = processUserData(osDetailsData)
    const collectedData = [...newData, ...moreData.data]
    const uniqueData = collectedData.filter((v, i, a) => a.findIndex(t => JSON.stringify(t) === JSON.stringify(v)) === i)

    return uniqueData.filter(row =>
      Object.keys(row).reduce((isVisible, key) => {
        return isVisible && meetsFilter(row[key], activeFilters[key] as any, FILTER_TYPES.QUICK_SEARCH)
      }, true),
    )
  }, [activeFilters, moreData.data, osDetailsData, processUserData])

  const onLoadMoreRows = useCallback(
    async ({ startIndex, stopIndex }) => {
      setMoreData({ data: [...moreData.data, ...processUserData(osDetailsData)], cursor: osDetailsData?.data?.next })
    },
    [moreData.data, osDetailsData, processUserData],
  )

  const infiniteLoader = {
    rowCount: localData.length,
    isRowLoaded: index => !!localData[index],
    loadMoreRows: onLoadMoreRows,
    threshold: 10,
    minimumBatchSize: 100,
  }

  return (
    value === index && (
      <Paper>
        <Box display="flex" flexDirection="column" height="90vh">
          <InfiniteTable
            noDataRenderer={noDataRenderer}
            rowCount={localData.length}
            rowGetter={({ index }) => localData[index]}
            infiniteLoader={infiniteLoader}
            headerRowRenderer={headerRowRenderer}
            headerHeight={HEADER_HEIGHT}
            rowHeight={ROW_HEIGHT}
            content={columns.map((column, index) => {
              return (
                <Column
                  key={column.dataKey}
                  headerRenderer={headerProps =>
                    headerRenderer({
                      ...headerProps,
                      column,
                      columnIndex: index,
                    })
                  }
                  className={classes?.tableCell}
                  cellRenderer={cellProps => cellRenderer({ ...cellProps, column })}
                  dataKey={column.dataKey}
                  {...standardWidth}
                  {...column}
                />
              )
            })}
          />
        </Box>
      </Paper>
    )
  )
})

export default UsersTab
