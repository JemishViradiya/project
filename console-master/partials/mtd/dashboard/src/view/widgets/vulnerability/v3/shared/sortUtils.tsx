import React, { useState } from 'react'
import { useTranslation } from 'react-i18next'

import { MenuItem, Select } from '@material-ui/core'

import type { MobileProtectData } from '@ues-data/mtd'
import type { TableSort } from '@ues/behaviours'
import { TableSortDirection } from '@ues/behaviours'

export enum ChartSortCriteria {
  Severity = 'severitySort',
  Os = 'osSort',
  Total = 'totalSort',
  Endpoints = 'endpointsSort',
}

export enum TableSortCriteria {
  Severity = 'severity',
  Date = 'date',
  Total = 'total',
}

export enum TableSortType {
  Literal = 'string',
  Numeric = 'number',
}

interface SortSelectProps {
  handleChange: (event: any) => void
}

export const sorterStyle = {
  padding: '12px 24px 12px 24px',
  'text-transform': 'uppercase',
  color: '#424242;',
  'font-weight': '600',
  'line-height': '1.5rem',
  'font-size': '14px',
  'font-family': 'Titillium Web,sans-serif',
}

function b2n(r: boolean): number {
  return r ? 1 : -1
}

export function getTotal(counts: MobileProtectData.SeverityCounts): number {
  return counts?.critical + counts?.high + counts?.medium + counts?.low + counts?.none
}

function totalSort(
  a: MobileProtectData.SeverityAndEndpointCountsByOs,
  b: MobileProtectData.SeverityAndEndpointCountsByOs,
): boolean {
  return getTotal(a.severityCount) < getTotal(b.severityCount)
}

function endpointsSort(
  a: MobileProtectData.SeverityAndEndpointCountsByOs,
  b: MobileProtectData.SeverityAndEndpointCountsByOs,
): boolean {
  return a.endpointCount < b.endpointCount
}

function severitySort(
  a: MobileProtectData.SeverityAndEndpointCountsByOs,
  b: MobileProtectData.SeverityAndEndpointCountsByOs,
): boolean {
  if (a.severityCount.critical === b.severityCount.critical) {
    if (a.severityCount.high === b.severityCount.high) {
      if (a.severityCount.medium === b.severityCount.medium) {
        return a.severityCount.low < b.severityCount.low
      }
      return a.severityCount.medium < b.severityCount.medium
    }
    return a.severityCount.high < b.severityCount.high
  }
  return a.severityCount.critical < b.severityCount.critical
}

function compositeSort(a: string, b: string, delimiter: string): boolean {
  if (a !== undefined && b !== undefined) {
    const as = a.split(delimiter)
    const bs = b.split(delimiter)
    if (as[0] === bs[0]) {
      if (as[1] === bs[1]) {
        return parseInt(as[2]) < parseInt(bs[2])
      }
      return parseInt(as[1]) < parseInt(bs[1])
    }
    return parseInt(as[0]) < parseInt(bs[0])
  } else if (a === undefined && b !== undefined) {
    return true
  } else if (b === undefined && a !== undefined) {
    return false
  } else {
    return true
  }
}

function osSort(a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs): number {
  if (a.os.platform === b.os.platform) {
    if (a.os.version === b.os.version) {
      return b2n(compositeSort(a.os.securityPatch, b.os.securityPatch, '-'))
    }
    return b2n(compositeSort(a.os.version, b.os.version, '.'))
  }
  return b.os.platform?.localeCompare(a.os.platform)
}

export const widgetChartSortHandler = (data: MobileProtectData.SeverityAndEndpointCountsByOs[], sortBy: ChartSortCriteria) => {
  if (sortBy === ChartSortCriteria.Total) {
    data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
      b2n(totalSort(a, b)),
    )
  } else if (sortBy === ChartSortCriteria.Severity) {
    data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
      b2n(severitySort(a, b)),
    )
  } else if (sortBy === ChartSortCriteria.Os) {
    data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
      osSort(a, b),
    )
  } else if (sortBy === ChartSortCriteria.Endpoints) {
    data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
      b2n(endpointsSort(a, b)),
    )
  }
  return data
}

export const panelChartSortHandler = (
  data: MobileProtectData.SeverityAndEndpointCountsByOs[],
  sortBy: ChartSortCriteria,
  sortDir: TableSortDirection,
) => {
  if (sortBy === ChartSortCriteria.Total) {
    if (sortDir === TableSortDirection.Asc) {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(totalSort(a, b)),
      )
    } else {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(totalSort(b, a)),
      )
    }
  } else if (sortBy === ChartSortCriteria.Severity) {
    if (sortDir === TableSortDirection.Asc) {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(severitySort(a, b)),
      )
    } else {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(severitySort(b, a)),
      )
    }
  } else if (sortBy === null || sortBy === ChartSortCriteria.Os) {
    if (sortDir === TableSortDirection.Asc) {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        osSort(a, b),
      )
    } else {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        osSort(b, a),
      )
    }
  } else if (sortBy === ChartSortCriteria.Endpoints) {
    if (sortDir === TableSortDirection.Asc) {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(endpointsSort(a, b)),
      )
    } else {
      data.sort((a: MobileProtectData.SeverityAndEndpointCountsByOs, b: MobileProtectData.SeverityAndEndpointCountsByOs) =>
        b2n(endpointsSort(b, a)),
      )
    }
  }
  return data
}

export const SortSelector: React.FC<SortSelectProps> = ({ handleChange }) => {
  const { t } = useTranslation(['mtd/common', 'mtd/vulnerability'])
  const [sortBy, setSortBy] = useState()

  const handleSortChange = event => {
    setSortBy(event.target.value)
    handleChange(event)
  }

  return (
    <Select value={sortBy ? sortBy : ChartSortCriteria.Os} onChange={handleSortChange} autoWidth={true}>
      <MenuItem value={ChartSortCriteria.Os}>{t(ChartSortCriteria.Os)}</MenuItem>
      <MenuItem value={ChartSortCriteria.Total}>{t(ChartSortCriteria.Total)}</MenuItem>
      <MenuItem value={ChartSortCriteria.Severity}>{t(ChartSortCriteria.Severity)}</MenuItem>
      <MenuItem value={ChartSortCriteria.Endpoints}>{t(ChartSortCriteria.Endpoints)}</MenuItem>
    </Select>
  )
}

function tableOsSort(a: MobileProtectData.Os, b: MobileProtectData.Os): number {
  if (a.platform === b.platform) {
    if (a.version === b.version) {
      return b2n(compositeSort(a.securityPatch, b.securityPatch, '-'))
    }
    return b2n(compositeSort(a.version, b.version, '.'))
  }
  return b.platform?.localeCompare(a.platform)
}

function createOsDataObject(platform: string, version: string, securityPatch: string): MobileProtectData.Os {
  return {
    platform: platform,
    version: version,
    securityPatch: securityPatch,
  }
}

function tableSorter(a: any, b: any, sortBy: string): number {
  if (sortBy === 'securityPatch') {
    return tableOsSort(
      createOsDataObject(a['platform'], a['version'], a['securityPatch']),
      createOsDataObject(b['platform'], b['version'], b['securityPatch']),
    )
  } else if (sortBy === 'version') {
    return tableOsSort(
      createOsDataObject(a['platform'], a['version'], undefined),
      createOsDataObject(b['platform'], b['version'], undefined),
    )
  } else if (sortBy === 'platform') {
    return tableOsSort(
      createOsDataObject(a['platform'], undefined, undefined),
      createOsDataObject(b['platform'], undefined, undefined),
    )
  } else if (sortBy === 'total') {
    return b2n(a['total'] < b['total'])
  } else if (sortBy === 'numEndpoints') {
    return b2n(a['numEndpoints'] < b['numEndpoints'])
  }
}

export function tableSortHandler(rowData: any, sort: TableSort) {
  if (sort.sortDir === TableSortDirection.Asc) {
    rowData.sort((a, b) => tableSorter(a, b, sort.sortBy))
  } else {
    rowData.sort((a, b) => tableSorter(b, a, sort.sortBy))
  }

  return rowData
}

function cveSeveritySort(a: any, b: any): boolean {
  const severityA = a.cvss3Impact.severity as MobileProtectData.Severity
  const severityB = b.cvss3Impact.severity as MobileProtectData.Severity
  if (severityA === severityB) {
    return cveDateSort(a, b)
  } else {
    return severityA < severityB
  }
}

function cveDateSort(a: any, b: any): boolean {
  return new Date(a.lastModifiedDate) > new Date(b.lastModifiedDate)
}

export function cveSortHandler(rowData: any, sort: TableSort) {
  if (sort.sortBy === TableSortCriteria.Severity) {
    if (sort.sortDir === TableSortDirection.Asc) {
      rowData.sort((a: MobileProtectData.CveSummary, b: MobileProtectData.CveSummary) => b2n(cveSeveritySort(a, b)))
    } else {
      rowData.sort((a: MobileProtectData.CveSummary, b: MobileProtectData.CveSummary) => b2n(cveSeveritySort(b, a)))
    }
  } else if (sort.sortBy === TableSortCriteria.Date) {
    if (sort.sortDir === TableSortDirection.Asc) {
      rowData.sort((a: MobileProtectData.CveSummary, b: MobileProtectData.CveSummary) => b2n(cveDateSort(a, b)))
    } else {
      rowData.sort((a: MobileProtectData.CveSummary, b: MobileProtectData.CveSummary) => b2n(cveDateSort(b, a)))
    }
  }
  return rowData
}

export function osKeySortHandler(oss: MobileProtectData.OsCount[]) {
  return oss.sort((a: MobileProtectData.OsCount, b: MobileProtectData.OsCount) => tableOsSort(a.os, b.os))
}
